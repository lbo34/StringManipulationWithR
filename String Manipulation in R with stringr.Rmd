---
title: "String Manipulation in R with stringr"
subtitle: "DataCamp course by Charlotte Wickham"
author: "Laurent Barcelo"
date: "September 19, 2018"
output: 
  html_notebook:
    toc: TRUE
    toc_depth: 2
---

# 1st Segment - String basics 

## Quotes

Let's get started by entering some strings in R. In the video you saw that you use quotes to tell R to interpret something as a string. Both double quotes (`"`) and single (`'`) quotes work, but there are some guidelines for which to use.

First, you should prefer double quotes (`"`) to single quotes (`'`). That means, whenever you are defining a string your first intuition should be to use `"`.

Unfortunately if your string has `"` inside it, R will interpret the double quote as "this is the end of the string", not as "this is the character `"`". This is one time you can forget the first guideline and use the single quote, `'`, to define the string.

Finally, there are cases where you need both `'` and `"` inside the string. In this case, fall back to the first guideline and use `"` to define the string, but you'll have to escape any double quotes inside the string using a backslash (i.e. `\"`).

To practice, you are going to enter a few lines from Lewis Carroll's Alice's Adventures in Wonderland. Alice has just arrived at the tea party...

#### Instructions
Following the guidelines for using quotes, define the three strings, `line1`, `line2 `and `line3`:

* Line 1: The table was a large one, but the three were all crowded together at one corner of it:
* Line 2: "No room! No room!" they cried out when they saw Alice coming.
* Line 3: "There's plenty of room!" said Alice indignantly, and she sat down in a large arm-chair at one end of the table.

```{r eval = F}
line1 <- "The table was a large one, but the three were all crowded together at one corner of it:"
line2 <- '"No room! No room!" they cried out when they saw Alice coming.'
line3 <- "\"There's plenty of room!\" said Alice indignantly, and she sat down in a large arm-chair at one end of the table."
```

## What you see isn't always what you have

Take a look at `line2`, the string you just defined, by printing it:

> line2

Even though you used single quotes so you didn't have to escape any double quotes, when R prints it, you'll see escaped double quotes (`\"`)! R doesn't care how you defined the string, it only knows what the string represents, in this case, a string with double quotes inside.

When you ask R for `line2` it is actually calling `print(line2)` and the `print()` method for strings displays strings as you might enter them. If you want to see the string it represents you'll need to use a different function: `writeLines()`.

You can pass `writeLines()` a vector of strings and it will print them to the screen, each on a new line. This is a great way to check the string you entered really does represent the string you wanted.

#### Instructions
We've put your lines from Alice's Adventures in Wonderland in a vector called `lines`.

* Take a look at `lines` to see R's representation of the strings.
* Pass lines to `writeLines()` to see the content of strings you've created.
* By default `writeLines()` separates the strings with a newline, which you can change using the `sep` argument. Write `lines` to the screen again, but this time set the sep argument to a space, `" "`.
* Finally, try using `writeLines()` on the string `"hello\n\U1F30D"`. You'll learn about what's going on here in the next exercise.

```{r eval = F}
lines <- c(line1, line2, line3)

lines
writeLines(lines)

writeLines(lines, sep = " ") 
## similar to 
cat(lines)

writeLines("hello\n\U1F30D")
```

## Escape sequences

You might have been surprised at the output from the last part of the last exercise. How did you get two lines from one string, and how did you get that little globe? The key is the `\`.

A sequence in a string that starts with a `\` is called an escape sequence and allows us to include special characters in our strings. You saw one escape sequence in the first exercise: `\"` is used to denote a double quote.

In `"hello\n\U1F30D"` there are two escape sequences: `\n` gives a newline, and `\U` followed by up to 8 hex digits sequence denotes a particular Unicode character.

Unicode is a standard for representing characters that might not be on your keyboard. Each available character has a Unicode code point: a number that uniquely identifies it. These code points are generally written in hex notation, that is, using base 16 and the digits 0-9 and A-F. You can find the code point for a particular character by looking up a [code chart](http://www.unicode.org/charts/). If you only need four digits for the codepoint, an alternative escape sequence is `\u`.

When R comes across a `\` it assumes you are starting an escape, so if you actually need a backslash in your string you'll need the sequence `\\`.

#### Instructions
* Edit the string inside `writeLines()` so that it correctly displays (all on one line):

> To have a \ you need \\

* Edit the string inside `writeLines()` so that it correctly displays (with the line breaks in these positions)

> This is a really  
> really really  
> long string

* Try `writeLines()` with the string containing Unicode characters: `"\u0928\u092e\u0938\u094d\u0924\u0947 \u0926\u0941\u0928\u093f\u092f\u093e"`. You just said "Hello World" in Hindi!

```{r eval = F}
writeLines("To have a \\ you need \\\\")
writeLines("This is a really \nreally really \nlong string")
writeLines("\u0928\u092e\u0938\u094d\u0924\u0947 \u0926\u0941\u0928\u093f\u092f\u093e")
```

## Using format() with numbers

The behavior of `format()` can be pretty confusing, so you'll spend most of this exercise exploring how it works.

Recall from the video, the scientific argument to `format()` controls whether the numbers are displayed in fixed (`scientific = FALSE`) or scientific (`scientific = TRUE`) format.

When the representation is scientific, the digits argument is the number of digits before the exponent. When the representation is fixed, digits controls the significant digits used for the smallest (in magnitude) number. Each other number will be formatted to match the number of decimal places in the smallest number. This means the number of decimal places you get in your output depends on all the values you are formatting!

For example, if the smallest number is 0.0011, and digits = 1, then 0.0011 requires 3 places after the decimal to represent it to 1 significant digit, 0.001. Every other number will be formatted to 3 places after the decimal point.

So, how many decimal places will you get if 1.0011 is the smallest number? You'll find out in this exercise.

#### Instructions
* Format `c(0.0011, 0.011, 1)` with `digits = 1`. This is like the example described above.
* Now, format `c(1.0011, 2.011, 1)` with `digits = 1`. Try to predict what you might get before you try it.
* Format `percent_change` by choosing the digits argument so that the values are presented with one place after the decimal point.
* Format `income` by choosing the `digits` argument so that the values are presented as whole numbers (i.e. no places after the decimal point).
* Format `p_values` using a fixed representation.

```{r eval = F}
percent_change  <- c(4, -1.91, 3.00, -5.002)
income <-  c(72.19, 1030.18, 10291.93, 1189192.18)
p_values <- c(0.12, 0.98, 0.0000191, 0.00000000002)

format(c(0.0011, 0.011, 1), digits = 1) 
format(c(1.0011, 2.011, 1), digits = 1) # significant digits

format(percent_change, digits = 2)
format(income, digits = 2)
format(p_values, scientific = FALSE)
```

## Controlling other aspects of the string

Not only does `format()` control the way the number is represented, it also controls some of the properties of the resulting string that affect its display.

For example, by default `format()` will pad the start of the strings with spaces so that the decimal points line up, which is really useful if you are presenting the numbers in a vertical column. However, if you are putting the number in the middle of a sentence, you might not want these extra spaces. You can set `trim = TRUE` to remove them.

When numbers are long it can be helpful to "prettify" them, for example instead of 1000000000 display 1,000,000,000. In this case a `,` is added every 3 digits. This can be controlled by the `big.interval` and `big.mark` arguments, e.g. `format(1000000000, big.mark = ",", big.interval = 3, scientific = FALSE)`. These arguments are actually passed on to [`prettyNum()`](https://www.rdocumentation.org/packages/base/versions/3.5.1/topics/formatC) so head there for any further details.

#### Instructions
We've assigned your formatted income from the previous exercise to `formatted_income`.

* Print `formatted_income` Notice the spaces at the start of the strings.
* Call `writeLines()` on the formatted income. Notice how the numbers line up on the decimal point.
* Define `trimmed_income` by using `format()` on `income` with `digits = 2` and `trim = TRUE`.
* Call `writeLines()` on `trimmed_income`. Notice how this removes the spaces at the start of the strings and the values line up on left.
* Define `pretty_income` by using `format()` on `income` with `digits = 2` and `big.mark = ","`.
* Call `writeLines()` on `pretty_income`.

```{r eval = F}
formatted_income <- format(income, digits = 2)
print(formatted_income)
writeLines(formatted_income)

trimmed_income <- format(income, digits = 2, trim = T)
writeLines(trimmed_income)

pretty_income <- format(income, digits = 2, big.mark = ",")
writeLines(pretty_income)
```

## formatC()

The function `formatC()` provides an alternative way to format numbers based on C style syntax.

Rather than a scientific argument, `formatC()` has a format argument that takes a code representing the required format. The most useful are:

* "f" for fixed,
* "e" for scientific (engineering?), and
* "g" for fixed unless scientific saves space

When using scientific format, the `digits` argument behaves like it does in `format()`; it specifies the number of significant digits. However, unlike `format()`, when using fixed format, digits is the number of digits after the decimal point. **This is more predictable than `format()`, because the number of places after the decimal is fixed regardless of the values being formatted**.

`formatC()` also *formats numbers individually*, which means you always get the same output regardless of other numbers in the vector.

The `flag` argument allows you to provide some modifiers that, for example, force the display of the sign (`flag = "+"`), left align numbers (`flag = "-"`) and pad numbers with leading zeros (`flag = "0"`). You'll see an example in this exercise.

#### Instructions
The vectors `income`, `percent_change`, and `p_values` are available in your workspace.

* First, compare the behavior of `formatC()` to `format()` by calling `formatC()` on `x` with `format = "f"` and `digits = 1`. This is the same vector you used with `format()`, do you see the difference?
* Call `formatC()` on `y` with `format = "f"` and `digits = 1`. Notice how digits has consistent behavior regardless of the vector you format.
* Format `percent_change` to one decimal place after the decimal point.
* Format` percent_change` to one decimal place after the decimal point and add `flag = "+"`. This forces the display of the sign.
* Format `p_values` using `format = "g"` and `digits = 2`. This can be useful, since if there are any `p-values` in scientific notation, they must be` < 0.0001`.

```{r eval = F}
x <- c(0.0011, 0.011, 1)
y <- c(1.0011, 2.011, 1)

format(x, digits = 1)
formatC(x, format = "f", digits = 1)

formatC(y, format = "f", digits = 1)

formatC(percent_change, format = "f", digits = 1)
formatC(percent_change, format = "f", digits = 1, flag = "+")

formatC(p_values, format = "g", digits = 2)
```


## Annotation of numbers

To get a handle on using `paste()`, you are going to annotate some of your formatted number strings.

The key points to remember are:

* The vectors you pass to `paste()` are pasted together element by element, using the sep argument to combine them.
* If the vectors passed to `paste()` aren't the same length, the shorter vectors are recycled up to the length of the longest one.
* Only use `collapse `if you want a single string as output. `collapse` specifies the string to place between different elements.

#### Instructions
We've put the formatted vectors `pretty_income` and `pretty_percent` in your workspace along with `years`.

* Paste a `$` to the front of each value in `pretty_income`, use `sep = ""`, so there is no space between the `$` and value.
* Paste a `%` to the end of each value in `pretty_percent`, use `sep = ""`, so there is no space between the value and the `%`.
* `years` contains the year each `pretty_percent` corresponds to. Use `paste()` to produce a vector with elements like `2010: +4.0%` and assign it to `year_percent`.
* Use `paste()` with `year_percent` to create single string that collapses all the years: `2010: +4.0%, 2011: -1.9%, 2012: +3.0%, 2013: -5.0%`.

```{r eval = F}
# data prep
pretty_income <- format(income, digits = 2, big.mark = ",", trim = T)
pretty_percent <- formatC(percent_change, format = "f", digits = 1, flag = "+")
years <- seq(from = 2010, to = 2013)


paste("$", pretty_income, sep = "")
paste(pretty_percent, "%",  sep = "")
year_percent <- paste(years, ": ", pretty_percent, "%", sep = "")
paste(year_percent, collapse = ", ", sep = "")

# all this equivalent to paste0 without the sep = "" argumentpaste("$", pretty_income, sep = "")
paste0("$", pretty_income)
paste0(pretty_percent, "%")
year_percent <- paste0(years, ": ", pretty_percent, "%")
paste0(year_percent, collapse = ", ")
```

## A very simple table

Combining `format()` and `paste()` is one way to display very simple tables. Remember, since `format()` looks at all the values in a vector before formatting, it uses a consistent format and will, by default, align on the decimal point. This is usually the behavior you want for a column of numbers in table.

`format()` can also take character vectors as input. In this case, you can use the `justify` argument, specific to character input, to justify the text to the `left`, `right`, or `center`.

You are going to put together the following table:

>          Year 0   $       72  
>          Year 1   $    1,030  
>          Year 2   $   10,292  
>Project Lifetime   $1,189,192

You'll start by formatting the columns to prepare to put them in a table, then you'll use `paste()` to put together each row. Then, you can use `writeLines()` to display each row on a new line.


#### Instructions
The `income` vector is loaded in your workspace.

* Create `pretty_income` by using `format()` with `digits = 2` and `big.mark = ","`.
* Create `dollar_income` by pasting `$` to `pretty_income` (don't forget to set the sep argument).
* Create `formatted_names` by using `format()` on `income_names` with `justify = "right"`.
* Create `rows` by pasting together `formatted_names` and `dollar_income`. Use three spaces as a separator to give some room between your columns. Be sure to surround your separator in `"`.
* Call `writeLines()` on rows to see your table.

```{r eval = F}
income_names <- c("Year 0", "Year 1", "Year 2", "Project Lifetime")

pretty_income <- format(income, digits = 2, big.mark = ",")
(dollar_income <- paste0("$", pretty_income))
formatted_names <- format(income_names, justify = "right")
(rows <- paste0(formatted_names, "   ", dollar_income))
writeLines(rows)
```

## Let's order pizza!

As a final exercise in using `paste()` and to celebrate getting to the end of the first chapter, let's order some pizza.

We've got a list of possible pizza toppings in `toppings`.

You are going to randomly select three toppings, and then put them together using `paste()` into an order for pizza, that should result in a string like,

> "I want to order a pizza with mushrooms, spinach, and pineapple."

#### Instructions
* Print `my_toppings` to see your random toppings.
* Add `"and "` to the start of the third element by using `paste()` with `my_toppings` and a vector you define.
* Create a vector `these_toppings` by using `paste()` to collapse `my_toppings_and` with a comma and space between each element.
* Create `my_order` by pasting `"I want to order a pizza with "` to these_toppings and ending with a period, `"."`.
* Order your pizza by calling `writeLines()` on `my_order`.

```{r eval = F}
toppings <- c('anchovies', 'artichoke', 'bacon', 'breakfast bacon', 'Canadian bacon', 'cheese', 'chicken', 'chili peppers', 'feta', 'garlic', 'green peppers', 'grilled onions', 'ground beef', 'ham', 'hot sauce', 'meatballs', 'mushrooms', 'olives', 'onions', 'pepperoni', 'pineapple', 'sausage', 'spinach', 'sun-dried tomato', 'tomatoes')

my_toppings <- sample(toppings, size = 3)

my_toppings
my_toppings_and <- paste0( c("", "", "and "), my_toppings)
these_toppings <- paste(my_toppings_and, collapse = ", ")
my_order <- paste0("I want to order a pizza with ", these_toppings, ".")
writeLines(my_order)
```

# 2nd Segment - Introduction to stringr

## Putting strings together with stringr

For your first stringr function, we'll look at `str_c()`, the `c` is short for concatenate, a function that works like `paste()`. It takes vectors of strings as input along with sep and collapse arguments.

There are two key ways `str_c()` differs from `paste()`. First, the default separator is an empty string, `sep = ""`, as opposed to a space, so it's more like `paste0()`. This is an example of a stringr function, performing a similar operation to a base function, but using a default that is more likely to be what you want. Remember in your pizza order, you had to set `sep = ""` multiple times.

The second way `str_c()` differs to `paste()` is in its handling of missing values. `paste()` turns missing values into the string `"NA"`, whereas `str_c()` propagates missing values. That means combining any strings with a missing value will result in another missing value.

Let's explore this difference using your pizza order from the previous chapter.

#### Instructions
We've set up a new `my_toppings` vector that has a few missing values and taken the first step of creating our order.

Print `my_toppings_and` to see what `paste()` did with the missing values.
Repeat the `paste()` statement but instead use `str_c()`. You can save some typing by leaving off `sep = ""` since that is the default. Call this string `my_toppings_str`.
Print `my_toppings_str` to see what `str_c()` does with the missing values.
Take the next step in our order, by using `paste()` on `my_toppings_and` with `collapse = ", "`.
Take the next step in our order, by using `str_c()` on `my_toppings_str` with `collapse = ", "`. *See the difference: just one NA will make our entire result NA.*

```{r eval = F}
library(stringr)

my_toppings <- c("cheese", NA, NA)
my_toppings_and <- paste(c("", "", "and "), my_toppings, sep = "")

my_toppings_and

my_toppings_str <- str_c(c("", "", "and "), my_toppings)
my_toppings_str

paste(my_toppings_and, collapse = ", ")
str_c(my_toppings_str, collapse = ", ")

#NOTE: str_replace_na() replaces missing values with any string you choose.
```

## String length

Our next `stringr` function is `str_length()`. `str_length()` takes a vector of strings as input and returns the number of characters in each string. For example, try finding the number of characters in Batman's name:

> str_length(c("Bruce", "Wayne"))

This is very similar to the base function `nchar()` but you'll see in the exercises `str_length()` handles factors in an intuitive way, whereas `nchar()` will just return an error.

Historically, `nchar()` was even worse, rather than returning an error if you passed it a factor, it would return the number of characters in the numeric encoding of the factor. Thankfully this behavior has been fixed, but it was one of the original motivations behind `str_length()`.

Take your first look at `babynames` by asking if girls' names are longer than boys' names.

#### Instructions
We've pulled out just the names from 2014, and created the vectors `boy_names` and `girl_names` for you. (If you want to learn about the filter() function, take the Data Manipulation in R with dplyr course!).

* Take a look at the `boy_names` vector, it's long, so use `head()` to see the first few elements.
* Use `str_length()` on boy_names to find the length of each name and save the result to `boy_length`.
* Take a look at the lengths. Again, use `head()`. Can you see the correspondence with boy_names?
* Find the length of all the girls' names. Call this `girl_length`.
* Find the difference in mean length between boys' and girls' names by subtracting the mean length of boys' names from that of girls' names.
* Confirm `str_length()` works on factors, by calling it on `factor(boy_names)`. Again, you'll want to just look at the `head()`.

```{r eval = F}
library(stringr)
library(babynames)
library(dplyr)

# Extracting vectors for boys' and girls' names
babynames_2014 <- filter(babynames, year == 2014)
boy_names <- filter(babynames_2014, sex == "M")$name
girl_names <- filter(babynames_2014, sex == "F")$name

head(boy_names)
boy_length <- str_length(boy_names)
head(boy_length)

girl_length <- str_length(girl_names)
head(girl_length)

mean(boy_length) - mean(girl_length)

head(str_length(factor(boy_names)))
```

## Extracting substrings

The `str_sub()` function in stringr extracts parts of strings based on their location. As with all `stringr` functions, the first argument, `string`, is a vector of strings. The arguments `start` and `end` specify the boundaries of the piece to extract in characters.

For example, `str_sub(x, 1, 4)` asks for the substring starting at the first character, up to the fourth character, or in other words the first four characters. Try it with my Batman's name:

> str_sub(c("Bruce", "Wayne"), 1, 4)

Both start and end can be negative integers, in which case, they count from the end of the string. For example, `str_sub(x, -4, -1)`, asks for the substring starting at the fourth character from the end, up to the first character from the end, i.e. the last four characters. Again, try it with Batman:

> str_sub(c("Bruce", "Wayne"), -4, -1)

To practice, you'll use `str_sub()` to look at popular first and last letters for names.

#### Instructions
We've set up the same `boy_names` and `girl_names` vectors from the last exercise in your workspace.

* Use `str_sub()` to extract the first letter of each name in `boy_names`. Save this to `boy_first_letter`.
* Use `table()` on boy_first_letter to count up how many names start with each letter. Can you see which is most popular?
* Repeat these steps, but now look at the last letter for boys' names.
* Again repeat, but now look at the first letter for girls' names.
* Finally, look at the last letter for girls' names.

```{r eval = F}
boy_first_letter <- str_sub(string = boy_names, start = 1, end = 1)
table(boy_first_letter)

boy_last_letter <- str_sub(string = boy_names, start = -1, end = -1)
table(boy_last_letter)

girl_first_letter <- str_sub(girl_names, start = 1, end = 1)
table(girl_first_letter)

girl_last_letter <- str_sub(string = girl_names, start = -1, end = -1)
table(girl_last_letter)
```

## Detecting matches

`str_detect()` is used to answer the question: Does the string contain the pattern? It returns a logical vector of the same length as that of the input vector string, with `TRUE` for elements that contain the pattern and `FALSE` otherwise.

Let's take a look at a simple example where you have a vector of strings that represent pizza orders:

> pizzas <- c("cheese", "pepperoni",   
  "sausage and green peppers")
  
You can ask which orders contain the pattern `"pepper"`, with

> str_detect(pizzas,  
  pattern = fixed("pepper"))

Try it out! You should get `FALSE TRUE TRUE`. Notice how both pepperoni and green peppers contain the pattern of interest.

The output from `str_detect()` can be used to count the number of occurrences, or to subset out the strings that contain the pattern. You'll practice both to find the boys' names that contain "zz".

#### Instructions
* Use `str_detect()` to find which boy_names contain "zz". Save the result to `contains_zz`.
* Examine the structure of `contains_zz` with `str()`. It should be a logical vector the same length as boy_names.
* To find out how many names in boy_names contain "zz", use `sum()` on `contains_zz`. Recall summing a logical vector counts how many are `TRUE`.
* To find the names in `boy_names` that contain "zz", subset `boy_names` using `[` and `contains_zz`.
* We've also included `boy_df` in your workspace, a data frame that corresponds to the boys' names in 2014. Subset the rows of `boy_df` using `contains_zz`.

```{r eval = F}
boy_df <- babynames_2014 %>% filter(sex == "M")

contains_zz <- str_detect(string = boy_names, pattern = fixed("zz"))

str(contains_zz)
sum(contains_zz)

boy_names[contains_zz]
boy_df[contains_zz,]
```

## Subsetting strings based on match

Since detecting strings with a pattern and then subsetting out those strings is such a common operation, `stringr` provides a function `str_subset()` that does that in one step.

For example, let's repeat our search for "pepper" in our pizzas using str_subset():

> pizzas <- c("cheese", "pepperoni", "sausage and green peppers")  
> str_subset(pizzas, pattern = fixed("pepper"))

We get a new vector of strings, but it only contains those original strings that contained the pattern.

`str_subset()` can be easily confused with `str_extract()`. `str_extract()` returns a vector of the same length as that of the input vector, but with only the parts of the strings that matched the pattern. This won't be very interesting until we know about regular expressions, so we'll talk more about this in Chapter 3.

For now, you'll repeat part of the last exercise using `str_subset()` and then find a few other interesting names.

#### Instructions
* Find the `boy_names` that contain `"zz"`, using `str_subset()`.
* Find the `girl_names` that contain `"zz`".
* Find the `girl_names` that contain `"U"` and save into `starts_U`. Since the pattern matching is case sensitive, this will only be names that start with `"U"`.
* Feed `starts_U` into another `str_subset()` that looks for `"z"`. Combining multiple `str_subset()` calls is a way to find more complicated patterns.

```{r eval = F}
str_subset(string = boy_names, pattern = fixed("zz"))
str_subset(string = girl_names, pattern = fixed("zz"))
starts_U <- str_subset(string = girl_names, pattern = fixed("U"))
str_subset(starts_U, pattern = fixed("z"))
```

## Counting matches

Another `stringr` function that takes a vector of strings and a pattern is `str_count()`. `str_count()` answers the question "How many times does the pattern occur in **each** string?". It always returns an integer vector of the same length as that of the input vector.

If you count the occurrences of "pepper" in your pizzas, you'll find no occurrences in the first, and one each in the second and third,

> pizzas <- c("cheese", "pepperoni",   
>  "sausage and green peppers")  
> str_count(pizzas, pattern = fixed("pepper"))

Perhaps a little more interesing is to count how many `"e"`s occur in each order

> str_count(pizzas, pattern = fixed("e"))

You'll use `str_count()` to find some names with lots of repeated letters.

#### Instructions
* Count the number of `"a"` in each `girl_names`, store in `number_as`.
* Count the number of `"A"` in each `girl_names`, store in `number_As`.
* Create histograms, use the `hist()` function, of `number_as` and `number_As`. Why is `number_As` only zero or one?
* Add together `number_as` and `number_As` to get `total_as`.
* Subset `girl_names` to only those names where `total_as > 4`.

```{r eval = F}
number_as <- str_count(string = girl_names, pattern = fixed("a"))
number_As <- str_count(string = girl_names, pattern = fixed("A"))

hist(number_as)
hist(number_As)

total_as <- number_as + number_As
girl_names[total_as > 4]
```

## Parsing strings into variables

A common use for `str_split()` is to pull apart raw string data into more useful variables. In this exercise you'll start by pulling apart a date range, something like `"23.01.2017 - 29.01.2017"`, into separate variables for the start of the range, `"23.01.2017"`, and the end of the range, `"29.01.2017"`.

Remember, if the `simplify` argument is `FALSE` (the default) you'll get back a list of the same length as that of the input vector. More commonly, you'll want to pull out the first piece (or second piece etc.) from every element, which is easier if you specify `simplify = TRUE` and get a matrix as output. You'll explore both of these output types in this exercise.

#### Instructions
* Split `date_ranges` using `" - "` as a pattern, assign this to `split_dates`. Don't forget to wrap the pattern in `fixed()`. Print  split_dates`. The result is a list with two elements, since `date_ranges` was a vector of length two.
* Now, split `date_ranges` again, but specify `simplify = TRUE` and `n = 2`. Print the result to see the difference. Now we get a matrix back, where each row corresponds to an element of `date_ranges`.
* Pull out the first column of `split_dates_n` into `start_dates`.
* Split `start_dates` into its day, month and year components. You are aiming for a three column matrix as the result.
* Now you're on your own. We've provided the `both_names` vector, listing a couple of famous statisticians. Your job is to pull out the first names and last names into separate vectors. You'll need to use an intermediate variable, `both_names_split`.

```{r eval = F}
# Some date data
date_ranges <- c("23.01.2017 - 29.01.2017", "30.01.2017 - 06.02.2017")
both_names <- c("Box, George", "Cox, David")

split_dates <- str_split(string = date_ranges, pattern = fixed(" - "))
split_dates

split_dates_n <- str_split(string = date_ranges, pattern = fixed(" - "), simplify = T, n = 2)
split_dates_n

start_dates <- split_dates_n[,1]
str_split(start_dates, pattern = fixed("."), simplify = T, n = 3)

both_names_split <- str_split(string = both_names, pattern = fixed(", "), simplify = T, n=2)
first_names <- both_names_split[,2]
last_names <- both_names_split[,1]
```

## Some simple text statistics

Generally, specifying `simplify = TRUE` will give you output that is easier to work with, but you'll always get `n` pieces (even if some are empty, `""`).

Sometimes, you want to know how many pieces a string can be split into, or you want to do something with every piece before moving to a simpler structure. This is a situation where you don't want to simplify and you'll have to process the output with something like `lapply()`.

As an example, you'll be performing some simple text statistics on your lines from Alice's Adventures in Wonderland from Chapter 1. Your goal will be to calculate how many words are in each line, and the average length of words in each line.

To do these calculations, you'll need to split the lines into words. One way to break a sentence into words is to split on an empty space " ". This is a little naive because, for example, it wouldn't pick up words separated by a newline escape sequence like in `"two\nwords"`, but since this situation doesn't occur in your lines, it will do.

#### Instructions
We've put `lines` a vector with three strings, each corresponding to a line in your workspace.

* Split lines into words. Assign the resulting list to words.
* Use `lapply()` to apply `length()` to each element in words to count the number of words in each line.
* Use `lapply()` to apply `str_length()` to each element in words, to count the number of characters in each word. Assign this to `word_lengths`.
* Use `lapply()` to apply `mean()` to each element in word_lengths, to find the average word length in each line.

```{r eval = F}
lines <- c("The table was a large one, but the three were all crowded together at one corner of it:", "\"No room! No room!\" they cried out when they saw Alice coming.", "\"There’s plenty of room!\" said Alice indignantly, and she sat down in a large arm-chair at one end of the table.")

words <- str_split(string = lines, pattern = fixed(" "))

lapply(X = words, FUN = length)
word_length <- lapply(words, str_length)
lapply(word_length, mean)
```

## Replacing to tidy strings

You've seen one common strategy to pull variables out of strings is to split the string based on a pattern. Sometimes, it's easier to just replace the parts you don't want with an empty string `""`. This is also a common strategy to clean strings up, for example, to remove unwanted punctuation or white space.

In this exercise you'll pull out some numbers by replacing the part of the string that isn't a number, you'll also play with the format of some phone numbers. Pay close attention to the difference between `str_replace()` and `str_replace_all()`.

#### Instructions
* Keep the numeric part of `ids`, by replacing `"ID#: "` with an empty string `""`.
* Turn the ID strings to numbers using `as.numeric()`, assign the result to `id_ints`
* Use `str_replace()` on `phone_numbers` to replace the `"-"` with a space, `" "`. Take a close look at the output, are there still some `"-"`s?
* Repeat the previous task but now use `str_replace_all()`. Notice the difference, all the `"-"`s are replaced!
* Reformat the phone numbers to use dots instead of dashes, i.e. in the format `xxx.xxx.xxxx`.

```{r eval = F}
# Some IDs
ids <- c("ID#: 192", "ID#: 118", "ID#: 001")

id_nums <- str_replace(string = ids, pattern = fixed("ID#: "), replacement = "")
id_ints <- as.integer(id_nums)

# Some (fake) phone numbers
phone_numbers <- c("510-555-0123", "541-555-0167")

str_replace(phone_numbers, fixed("-"), " ")
str_replace_all(phone_numbers, fixed("-"), " ")
str_replace_all(phone_numbers, fixed("-"), fixed("."))
```

## Review

You've covered a lot of stringr functions in this chapter:

* `str_c()`
* `str_length()`
* `str_sub()`
* `str_detect()`
* `str_subset()`
* `str_count()`
* `str_split()`
* `str_replace()`

As a review we've got a few tasks for you to do with some DNA sequences. We've put three sequences, corresponding to three genes, from the genome of Yersinia pestis – the bacteria that causes bubonic plague – into the vector `gene`s.

Each string represents a gene, each character a particular nucleotide: Adenine, Cytosine, Guanine or Thymine.

We aren't going to tell you which function to use. It's up to you to choose the right one and specify the needed arguments. Good luck!

#### Instructions
* Find the number of nucleotides in each gene.
* Find the number of A's that occur in each gene.
* Return the sequences that contain the sequence "TTTTTT".
* Replace all the As in the sequences with a _.

```{r}
genes <- readRDS("/Users/lbarcelo/R_Repo/DataCamp/String Manipulation in R with stringr/Data/dna.rds")

str(genes)

str_length(genes)
str_count(genes, pattern = fixed("A"))
str_subset(genes, pattern = fixed("TTTTTT"))
str_replace_all(genes, fixed("A"), fixed("_"))
```

## Final challenges

You've mastered using `stringr` functions on their own, but by combining multiple operations together in sequence you can achieve quite complicated manipulations.

As the final exercise we want to expose you to the power of combining operations. You'll complete two tasks:

You'll turn a vector of full names, like `"Bruce Wayne"`, into abbreviated names like `"B. Wayne"`. This requires combining `str_split()`, `str_sub()` and `str_c()`.

You'll compare how many boy names end in `"ee"` compared to girl names. This requires combining `str_sub()` with `str_detect()` along with the base function `table()`.

#### Instructions
* Use `str_split()` to create a two column matrix with the first names in one column and the last names in the other. *You'll be manipulating the first name before combining it back with the second name in the next few steps*.
* Create an abbreviation of the first name, `abb_first`, by extracting just the first character with `str_sub()`.
* Use `str_c()` to combine `abb_first` with `". "` and the last name column to finish the task!
* Use `str_sub()` to extract the last two letters from `all_names`.
* Create a logical, `ends_in_ee` that identifies whether the `last_two_letters` are `ee`, using `str_detect()`.
* Subset the rows of `babynames_2014` using `ends_in_ee` and keep only the `sex` column. (Use the `$` notation to subset the `sex` column.)
* Apply `table()` to the result to complete the task!

```{r eval = F} 
names <- c("Diana Prince", "Clark Kent")

names_split <- str_split(string = names, pattern = " ", simplify = T)
abb_first <- str_sub(string = names_split[,1], start = 1, end = 1)
str_c(abb_first, ". ", names_split[,2])

# Use all names in babynames_2014
all_names <- babynames_2014$name

last_two_letters <- str_sub(string = all_names, start = -2, end = -1)
ends_in_ee <- str_detect(string = last_two_letters, pattern = fixed("ee"))
sex <- babynames_2014[ends_in_ee,]$sex
table(sex)
```

# 3rd Segment - Pattern matching with regular expressions

## Matching the start or end of the string

`rebus` provides `START` and `END` shortcuts to specify regular expressions that match the start and end of the string. These are also known as anchors. You can try it out just by typing

> START

You'll see the output `<regex> ^`. The `<regex>` denotes this is a special regex object and it has the value `^`. `^` is the character used in the regular expression language to denote the start of a string.

The special operator provided by rebus, `%R%` allows you to compose complicated regular expressions from simple pieces. When you are reading rebus code, think of `%R%` as "then". For example, you could combine `START` with `c`,

> START %R% "c"

to match the pattern "the start of string then a c", or in other words: strings that start with c. In rebus, if you want to match a specific character, or a specific sequence of characters, you simply specify them as a string, e.g. surround them with `"`.

#### Instructions
* Which character is used to match the end of a string? Print `END` to find out.
* `str_view()` from `stringr` is really helpful for testing your patterns. Run this line of code to see the matches in x to the pattern `START %R% "c"`.  
* Provide the pattern argument to match strings that start in `"co"`
* Provide the pattern argument to match strings that end in `"at"`. Think about this as matching an "at" followed by the end of the string.
* Provide the pattern argument to match strings that are `"cat"` exactly. Think about this as matching the start of the string, followed by "cat" and then the end of the string.

```{r eval = F}
# Some strings to practice with
x <- c("cat", "coat", "scotland", "tic toc")

END
str_view(x, pattern = START %R% "c")

str_view(x, pattern = START %R% "co")

str_view(x, pattern = "at" %R% END)

str_view(x, pattern = START %R% "cat" %R% END)
```

## Matching any character

In a regular expression you can use a wildcard to match a single character, no matter what the character is. In rebus it is specified with `ANY_CHAR`. Try typing `ANY_CHAR` in the console. You should see that in the regular expression language this is specified by a dot, `.`.

For example, `"c" %R% ANY_CHAR %R% "t"` will look for patterns like "c_t" where the blank can be any character. Consider the strings: "cat", "coat", "scotland" and "tic toc". Where would the matches to `"c" %R% ANY_CHAR %R% "t"` be?

Test your intuition by running:

> str_view(c("cat", "coat", "scotland", "tic toc"),  
>  pattern = "c" %R% ANY_CHAR %R% "t")

Notice that `ANY_CHAR` will match a space character (`c t` in `tic toc`). It will also match numbers or punctuation symbols, but `ANY_CHAR` will only ever match one character, which is why we get no match in coat.

#### Instructions
* Match any character followed by a `t`
* Match a `t` followed by any character. *Notice how the final `t` in cat and coat don't match, that's because there is no character after the `t` to match to `ANY_CHAR`*.
* Match any two characters. *Notice the first two characters are matched. Regular expression are lazy and will take the first match they find*.
* Match a string that is exactly three characters.

```{r eval = F}
str_view(x, pattern = ANY_CHAR %R% "t")

str_view(x, pattern = "t" %R% ANY_CHAR)

str_view(x, pattern = ANY_CHAR %R% ANY_CHAR)

str_view(x, pattern = START %R% ANY_CHAR %R% ANY_CHAR %R% ANY_CHAR %R% END)
```

## Combining with stringr functions

You can pass a regular expression as the `pattern` argument to any `stringr` function that has the `pattern` argument. You can use `str_detect()` to get a logical vector for whether there was a match, `str_subset()` to return just the strings with matches, and `str_count()` to count the number of matches in each string.

As a reminder, compare the output of those three functions with our `"c_t"` pattern from the previous exercise:

> x <- c("cat", "coat", "scotland", "tic toc")  
> pattern <- "c" %R% ANY_CHAR %R% "t"  
> str_detect(x, pattern)  
> str_subset(x, pattern)  
> str_count(x, pattern)  

It now also makes sense to add `str_extract()` to your repertoire. It returns just the part of the string that matched the pattern:

> str_extract(x, pattern)

You'll combine your regular expression skills with `stringr` to ask how often a `q` is followed by any character in boy names.

It's always a good idea to test your pattern, so this pattern is shown matched with four names. *The first two shouldn't have matches (can you explain why?) but the last two should.*

#### Instructions
* Find the `boy_names` with the pattern by using `str_subset()`. Assign the result to `names_with_q`.
* Run `length()` on the result to find out how many there are.
* Find just the part of `boy_names` that matched with `str_extract()`. Assign the result to `part_with_q`.
* Run `table()` on the result to find out how many have `qu` and how many have other patterns.
* Check that there weren't any boy_names that might have had the pattern twice (you would have only found the first match) by using `str_count()`. Assign the result to `count_of_q`.
* Use `table()` on the result.
* Get a logical vector of whether or not each boy's name contains `q*` by calling `str_detect()`. Assign the result to `with_q`.
* Count the fraction of boy's names containing `q*` by calculating the `mean()` of `with_q`.

```{r eval = FALSE}
pattern <- "q" %R% ANY_CHAR

names_with_q <- str_subset(string = boy_names, pattern = pattern)
length(names_with_q)

part_with_q <- str_extract(boy_names, pattern = pattern)
table(part_with_q)

count_of_q <- str_count(boy_names, pattern = pattern)
table(count_of_q)

with_q <- str_detect(boy_names, pattern = pattern)
mean(with_q)
```

## Alternation

The `rebus` function `or()` allows us to specify a set of alternatives, which may be single characters or character strings, to be matched. Each alternative is passed as a separate argument.

For example, `or("grey", "gray")` allows us to detect either the American or British spelling:

> x <- c("grey sky", "gray elephant")  
> str_view(x, pattern = or("grey", "gray"))

Since these two words only differ by one character you could equivalently specify this match with `"gr" %R% or("e", "a") %R% "y"`, that is "a gr followed by, an e or an a, then a y".

Notice we've added the argument `match = TRUE` to `str_view()`, this will only display elements that had a match, which is useful when you are searching over many strings.

#### Instructions
* Create a pattern that matches `Jeffrey` or `Geoffrey` in `boy_names`. Assign this to `whole_names`.
* Create a pattern that matches `Je` or `Geo` followed by `ffrey`. Assign this to `common_ending`. You should get the same matches as the previous pattern.
* Create a pattern that matches `Je` or `Geo`, followed by `ff`, followed by one of `ry`, `ery`, `rey`, or `erey`. Assign this to `by_parts`.
* Create a pattern that matches `all girl_names` that start with `C` or `K` followed by `ath`. Assign this to `ckath`.

```{r eval = F}
whole_names <- or("Jeffrey", "Geoffrey")
str_view(boy_names, pattern = whole_names, match = T)

common_ending <- or("Je", "Geo") %R% "ffrey"
str_view(boy_names, pattern = common_ending, match = T)

by_parts <- or("Je", "Geo") %R% "ff" %R% or("ry", "ery", "rey", "erey")
str_view(boy_names, pattern = by_parts, match = T)

ckath <- or("C", "K") %R% "ath"
str_view(girl_names, pattern = ckath, match = T)
```

## Character classes

In regular expressions a character class is a way of specifying "match one (and only one) of the following characters". In `rebus` you can specify the set of allowable characters using the function `char_class()`.

This is another way you could specify an alternate spelling, for example, specifying "a gr followed by, either an a or e, followed by a y":

> x <- c("grey sky", "gray elephant")  
> str_view(x, pattern = "gr" %R% char_class("ae") %R% "y")

A negated character class matches "any single character that isn't one of the following", and in `rebus` is specified with `negated_char_class()`.

Unlike in other places in a regular expression you don't need to escape characters that might otherwise have a special meaning inside character classes. If you want to match `.` you can include `.` directly, e.g. `char_class(".")`. Matching a `-` is a bit trickier. If you need to do it, just make sure it comes first in the character class.

#### Instructions
* Create a character class that contains vowels, `a, e, i, o, u` and their upper case versions.
* Print `vowels`. In the regular expression language, a character class is put inside `[`.
* View the matches to the pattern vowels in `x` with `str_view()`. Notice how only the first vowel is matched.
* Find the number of vowels in each `boy_names` by combining `str_count()` with the vowels pattern.
* Find the number of characters in each `boy_names` with `str_length()`.
* Find the average number of vowels in `boy_names` using the `mean` of `num_vowels`.
* Look at the mean ratio of `num_vowels` and `name_length`

```{r eval = F}
x <-  c("grey sky", "gray elephant")

vowels <- char_class("aeiouAEIOU")
vowels
str_view(x, vowels) # matches only the first one
str_view_all(x, vowels) # matches all

num_vowels <- str_count(boy_names, pattern = vowels)
name_length <- str_count(boy_names)

mean(num_vowels)
mean(num_vowels/name_length)
```

## Repetition

The rebus functions `one_or_more()`, `zero_or_more()` and `optional()` can be used to wrap parts of a regular expression to allow a pattern to match a variable number of times.

Take our vowels pattern from the last exercise. You can pass it to `one_or_more()` to create the pattern that matches "one or more vowels". Take a look with these interjections:

> x <- c("ow", "ooh", "yeeeah!", "shh")  
> str_view(x, pattern = one_or_more(vowels))

You'll see we can match the single o in ow, the double o in ooh and the string of es followed by the a in yeeeah, but nothing in shh because there isn't a single vowel.

In contrast `zero_or_more()` will match even if there isn't an occurrence, try

> str_view(x, pattern = zero_or_more(vowels))

Since both yeeeah and shh start without a vowel, they match "zero vowels", and since regular expressions are lazy, they look no further and return the start of the string as a match.

#### Instructions
* Find `boy_names` that are only vowels, by combining `one_or_more()` with `vowels`. You will need to either specify `START` and `END` or `use exactly()`.
* Create a `negated_char_class()` that matches anything but a vowel. (Note: `negated_char_class(vowels)` is not the right answer!)
* Find `boy_names` that have no vowels, by combining `exactly()` and `one_or_more()` with `not_vowels`.

```{r eval = F}
str_view(boy_names,
         pattern = exactly(one_or_more(vowels)),
         match = T)

not_vowels <- negated_char_class("aeiouAEIOU")

# See names with no vowels
str_view(boy_names, 
  pattern = exactly(one_or_more(not_vowels)), 
  match = TRUE)
```

## Hunting for phone numbers

For your first task you are going to pull out the phone numbers from this vector of contact information:

> contact

You'll assume the phone numbers you are looking for follow the American standard of a three digit area code, a three digit exchange and then a four digit number, but each part could be separated by spaces or various punctuation symbols.

#### Instructions
* Phone numbers start with three digits. Create a pattern that matches three digits in a row. Use `str_view_all()` to test your pattern.
* There might be a range of separators, so make a separator pattern, that uses `char_class()` to combine a character class containing `-, ., (, ),` and ` `.
* Put together a pattern to match a whole phone number: an `optional` open parenthesis (`OPEN_PAREN`), followed by three digits, followed by zero or more separators, followed by three digits followed by zero or more separators, followed by four digits.
* Extract the phone number from contact, using `str_extract`.
* Try using `str_extract_all()` instead. Can you see the difference?

```{r eval = F}
contact <- c("Call me at 555-555-0191", "123 Main St", "(555) 555 0191", "Phone: 555.555.0191 Mobile: 555.555.0192")

three_digits <-  DGT %R% DGT %R% DGT
str_view_all(contact, pattern = three_digits)

separator <- char_class("-.() ") #minus needs to go first
str_view_all(contact, pattern = separator)

four_digits <- three_digits %R% DGT

phone_pattern <- optional(OPEN_PAREN) %R% three_digits %R% optional(CLOSE_PAREN) %R% separator %R% three_digits %R% separator %R% four_digits
str_view_all(contact, pattern = phone_pattern)

str_extract(contact, pattern = phone_pattern)
str_extract_all(contact, pattern = phone_pattern)
```

## Extracting age and gender from accident narratives

Recall from the video, you want to parse out age and gender from accident narratives. For example, this narrative

> 19YOM-SHOULDER STRAIN-WAS TACKLED WHILE PLAYING FOOTBALL W/ FRIENDS 

describes male of age 19, and this one

> TRIPPED OVER CAT AND LANDED ON HARDWOOD FLOOR. LACERATION ELBOW, LEFT. 33 YOF*

a female of age 33.

You are generally looking for a pattern with a number, something to indicate the units, e.g. `YO` or `YR` for years old, or `MO` for months old, and a character that identifies the gender.

In this exercise you'll build up a pattern to pull out the part of the narrative that has the age and gender information. Then, in the next exercise you'll parse out the age and gender into separate variables.

#### Instructions
* Create an age pattern that matches one or two digits. Test your pattern using `str_view()`.
* Create a unit pattern that matches an optional space, then one of `YO`, `YR` or `MO`.
* Check your pattern so far by using `str_view()` with the pattern `age %R% unit`.
* Create a gender pattern that matches an optional space then `M` or `F`.
* Check your pattern so far by using `str_view()` with the pattern `age %R% unit %R% gender`.
* Extract the `age-unit-gender` piece from each narrative using `str_extract()`.

```{r eval = F}
# data prep
narratives <- c("19YOM-SHOULDER STRAIN-WAS TACKLED WHILE PLAYING FOOTBALL W/ FRIENDS ", "31 YOF FELL FROM TOILET HITITNG HEAD SUSTAINING A CHI ",  "ANKLE STR. 82 YOM STRAINED ANKLE GETTING OUT OF BED ", "TRIPPED OVER CAT AND LANDED ON HARDWOOD FLOOR. LACERATION ELBOW, LEFT. 33 YOF*", "10YOM CUT THUMB ON METAL TRASH CAN DX AVULSION OF SKIN OF THUMB ", "53 YO F TRIPPED ON CARPET AT HOME. DX HIP CONTUSION ", "13 MOF TRYING TO STAND UP HOLDING ONTO BED FELL AND HIT FOREHEAD ON RADIATOR DX LACERATION", "14YR M PLAYING FOOTBALL; DX KNEE SPRAIN ", "55YOM RIDER OF A BICYCLE AND FELL OFF SUSTAINED A CONTUSION TO KNEE " , "5 YOM ROLLING ON FLOOR DOING A SOMERSAULT AND SUSTAINED A CERVICAL STRA IN") 

age <- or(DGT, DGT %R% DGT) # this can also be DGT %R% optional(DGT). You can also use dgt(1, 2) to match one or two digits
str_view_all(narratives, age)

unit <- optional(SPC) %R% or("YO", "YR", "MO")
str_view_all(narratives, age %R% unit)

gender <- optional(SPC) %R% char_class("MF")
str_view_all(narratives, age %R% unit %R% gender)

age_gender <- str_extract(narratives, age %R% unit %R% gender)

```

## Parsing age and gender into pieces

To finish up, you need to pull out the individual pieces and tidy them into usable variables.

There are a few ways you could get at one piece: you could extract out the piece you need, you could replace everything that isn't the piece you need with "", or you could try to split into the pieces you need. You'll try a few of these in this exercise and you'll see yet another way in the next chapter. For the first option, `stringr` has a nice convenience function, `str_remove()`, that works like `str_replace()` with `replacement = ""`.

One benefit of building up your pattern in pieces is you already have patterns for each part that you can reuse now.

#### Instructions
* Use `str_extract` with your `age `pattern to extract just the age from age_gender, then transform it to a number with `as.numeric()`.
* Create `genders` by using `str_remove()` with your `age %R% unit` pattern to replace everything except the gender with `""`.
* genders has a few extra spaces; remove them.
* Get `time_units` by using `str_extract()` on age_gender with your unit pattern.
* To know if the units are months or years we just need the first character after any spaces. Use `str_extract()` on time_units with the pattern `WRD` to get `time_units_clean`.
* Complete the final line to convert any ages reported in months to an age in years.

```{r eval = F}
age <- DGT %R% optional(DGT) # IMPORTANT: note  or(DGT, DGT %R% DGT) is NOT equivalent as it returs only the first digit

ages_numeric <- as.numeric(str_extract(age_gender, age))

genders <- str_remove(age_gender, age %R% unit)
genders <- str_remove_all(genders, one_or_more(SPC))
genders

time_units <- str_extract(age_gender, unit)
time_units

time_units_clean <- str_extract(time_units, WRD) # we use here the lazy behavior of str_extract
time_units_clean

ifelse(time_units_clean == "Y", ages_numeric, round(ages_numeric/12))
```


# 4th Segment - More advanced matching and manipulation

## Capturing parts of a pattern

In `rebus`, to denote a part of a regular expression you want to capture, you surround it with the function `capture()`. For example, a simple pattern to match an email address might be,

> email <- one_or_more(WRD) %R%  
>  "@" %R% one_or_more(WRD) %R%  
>  DOT %R% one_or_more(WRD)  
> str_view("(wolverine@xmen.com)", pattern = email)  

If you want to capture the part before the `@`, you simply wrap that part of the regular expression in `capture()`:

> email <- capture(one_or_more(WRD)) %R%  
>  "@" %R% one_or_more(WRD) %R%  
>  DOT %R% one_or_more(WRD)  
> str_view("(wolverine@xmen.com)", pattern = email) 

The part of the string that matches hasn't changed, but if we pull out the match with `str_match()` we get access to the captured piece:

> str_match("(wolverine@xmen.com)", pattern =  email)  

You'll explore this behavior with some more super hero email addresses.

#### Instructions
* Add some more `capture()` calls to the email pattern, to capture the part after the `@` but before the `.`; and the part after the `.`.
* Check that the whole email address is matched by using `str_view()` on `hero_contacts` with the `email` pattern.
* Use `str_match()` to pull out the match and capture the email pattern in `hero_contacts`, and print it to confirm all parts are captured.
* Assign the third column of `email_parts` to `host` and print it.

```{r eval = F}
hero_contacts <- c("(wolverine@xmen.com)", "wonderwoman@justiceleague.org", "thor@avengers.com")

# Capture parts between @ and . and after .
email <- capture(one_or_more(WRD)) %R% 
  "@" %R% capture(one_or_more(WRD)) %R% 
  DOT %R% capture(one_or_more(WRD)) 

str_view(hero_contacts, email)

email_parts <- str_match(hero_contacts, email)
email_parts

host <- email_parts[,3]
host
```

## Pulling out parts of a phone number

You can now go back to the phone number example from the previous chapter. You developed a pattern to extract the parts of string that looked like phone numbers, and now you have the skills to pull out the pieces of the number. Let's see if you can put your skills together to output the first phone number in each string in a common format.

#### Instructions
We've put the pieces of your pattern in your workspace, along with some text containing phone numbers in the variable `contact`.

* `phone_pattern` is the pattern you developed in the last chapter. Edit it to `capture()` each sequence of numbers.
* Use `str_match()` to grab all the pieces into `phone_numbers`.
* Put together the pieces with `str_c()` into the format `(XXX) XXX-XXXX`.

```{r eval = F}
phone_pattern <- capture(three_digits) %R% zero_or_more(separator) %R% 
           capture(three_digits) %R% zero_or_more(separator) %R%
           capture(four_digits)

phone_numbers <- str_match(contact, phone_pattern)
phone_numbers
str_c("(", phone_numbers[,2], ") ", phone_numbers[,3], "-", phone_numbers[,4])
```

## Extracting age and gender again

You can now also take another look at your pattern for pulling out age and gender from the injury narratives. In the last chapter you took two steps to extract the pattern and then pull it apart. Take a go at doing it in one step!

#### Instructions
We've written out your whole pattern here rather than use the pattern variables you created, because you'll need to capture pieces that were inside those patterns.

* Add `capture()` to your pattern to pull out the age, unit and gender parts of the pattern.
* Use `str_match()` to pull them out of narratives, and take a look.
* That's pretty good, but it might be nice just to capture the first letter of the units, e.g. the Y or M. Alter your pattern to capture a Y or M, and then optional()ly match O or R.
* Check your new pattern still picks out the right pieces with `str_view()`.
Pull out the pieces with `str_match()`.

```{r eval = F}
# Add capture() to get age, unit and sex
pattern <- capture(optional(DGT) %R% DGT) %R%  
  optional(SPC) %R% capture(or("YO", "YR", "MO")) %R%
  optional(SPC) %R% capture(or("M", "F"))

str_match(narratives, pattern)

pattern2 <- capture(optional(DGT) %R% DGT) %R%  
  optional(SPC) %R% capture(char_class("YM")) %R% optional(char_class("OR")) %R%
  optional(SPC) %R% capture(or("M", "F"))


str_view(narratives, pattern2)
str_match(narratives, pattern2)
```

## Using backreferences in patterns

Backreferences can be useful in matching because they allow you to find repeated patterns or words. Using a backreference requires two things: you need to `capture()` the part of the pattern you want to reference, and then you refer to it with `REF1`.

Take a look at this pattern: `capture(LOWER) %R% REF1`. It matches and captures any lower case character, then is followed by the captured character: it detects repeated characters regardless of what character is repeated. To see it in action try this:

> str_view(c("hello", "sweet", "kitten"),  
>  pattern = capture(LOWER) %R% REF1)

If you capture more than one thing you can refer to them with `REF2`, `REF3` etc. up to `REF9`, counting the captures from the left of the pattern.

Let's practice with `boy_names` again. You might notice a change in this dataset. We've converted all names to lower case; you'll learn how to do that in the next chapter.

#### Instructions
* In each case, assign the pattern argument, then view the matches by running the `str_view()` code.
* See all the `boy_names` with a letter repeated three times, by extending the pattern in the text above with another `REF1`. Assign the pattern to `repeated_three_times`.
* See all the `boy_names` with a pair of letters repeated twice, e.g. `abab`, by capturing two lower case characters, then referring to the capture with REF1. Assign the pattern to `pair_of_repeated`.
* See all the boy_names with a pair of letter followed by their reverse, e.g. `abba`, by capturing two lower case characters separately and combining with `REF2` and `REF1`. Assign the pattern to `pair_that_reverses`.
* See all the `boy_names` that are a four letter palindrome (a name that reads the same forwards and backwards) by wrappping the previous pattern in exactly(). Assign the pattern to four_letter_palindrome

```{r eval = F}
boy_names_orig <- boy_names
boy_names <- tolower(boy_names)

repeated_three_times <- capture(LOWER) %R% REF1 %R% REF1
str_view_all(string = boy_names, pattern = repeated_three_times, match = T)

pair_of_repeated <- capture(LOWER %R% LOWER) %R% REF1
str_view_all(string = boy_names, pattern = pair_of_repeated, match = T)

pair_that_reverses <- capture(LOWER) %R% capture(LOWER) %R% REF2 %R% REF1
str_view_all(string = boy_names, pattern = pair_that_reverses, match = T)

str_view_all(string = boy_names, pattern = exactly(pair_that_reverses), match = T)
```

## Replacing with regular expressions

Now, you've mastered matching with backreferences, you'll build up to replacing with backreferences, but first let's review `str_replace()` now that you've got regular expressions under your belt.

Remember `str_replace()` takes three arguments, `string` a vector of strings to do the replacements in, `pattern` that identifies the parts of strings to replace and `replacement` the thing to use as a replacement.

`replacement` can be a vector, the same length as `string`, each element specifies the replacement to be used in each string. Let's practice by anonymizing some of the contact objects you've seen so far.

#### Instructions
Text containing phone numbers has been pre-defined in a variable named `contact`.

* Replace a digit in contact with "X" using `str_replace()`.
* Replace all digits in contact with "X" using `str_replace_all()`. (`str_replace()` will only replace the first match to the pattern. `str_replace_all()` will replace all matches to the pattern.)
* Replace all digits in contact using `str_replace_all()`, but now specify the vector `c("X", ".", "*", "_")` as `replacement`. Notice how now each string uses a different replacement character.

```{r eval = F}
# View text containing phone numbers
contact

# Replace digits with "X"
str_replace(contact, DGT, "X")

# Replace all digits with "X"
str_replace_all(contact, DGT, "X")

# Replace all digits with different symbol
str_replace_all(contact, DGT, c("X", ".", "*", "_"))
```

## Replacing with backreferences

The `replacement` argument to `str_replace()` can also include backreferences. This works just like specifying patterns with backreferences, except the capture happens in the `pattern` argument, and the backreference is used in the `replacement` argument.

> x <- c("hello", "sweet", "kitten")  
> str_replace(x, capture(ANY_CHAR), str_c(REF1, REF1))

`capture(ANY_CHAR)` will match the first character no matter what it is. Then the replacement `str_c(REF1, REF1)` combines the captured character with itself, in effect doubling the first letter of each string.

You are going to use this to create some alternative, more lively accident narratives.

The strategy you'll take is to match words ending in "ING" then replace them with an adverb followed by the original word.

#### Instructions
* Build a pattern that finds words that end in `"ING"`. You'll want to check it against `narratives` using `str_view()`.
* Test out the replacement by using `str_replace() `with your pattern (don't forget to capture() it!) and a replacement `str_c("CARELESSLY", REF1, sep = " ")`.
* Build a vector with one adverb for each narrative by sampling 10 elements from `adverbs`.
* Do the final replacement by using `str_c(adverbs_10, REF1, sep = " ")`

```{r eval = F}
# data adverb not available
pattern <- one_or_more(WRD) %R% "ING" ## surprisingly, this works // detects all words ending with ING

str_view(narratives, pattern)

# Test replacement
str_replace(narratives, capture(pattern), str_c("CARELESSLY", REF1, sep = " "))

# One adverb per narrative
adverbs_10 <- sample(adverbs, 10)

# Replace "***ing" with "adverb ***ly"
str_replace(narratives, capture(pattern), str_c(adverbs_10, REF1, sep = " "))
```

## Matching a specific code point or code groups

Things can get tricky when some characters can be specified two ways, for example è, an e with a grave accent, can be specified either with the single code point `\u00e8` or the combination of a `\u0065` and a combining grave accent `\u0300`. They look the same:

> x <- c("\u00e8", "\u0065\u0300")
> writeLines(x)

But, specifying the single code point only matches that version:

> str_view(x, "\u00e8")

The `stringi` package that `stringr` is built on contains functions for converting between the two forms. `stri_trans_nfc()` composes characters with combining accents into a single character. `stri_trans_nfd()` decomposes character with accents into separate letter and accent characters. You can see how the characters differ by looking at the hexadecimal codes.

> as.hexmode(utf8ToInt(stri_trans_nfd("\u00e8")))
> as.hexmode(utf8ToInt(stri_trans_nfc("\u0065\u0300")))

In Unicode, an accent is known as a diacritic Unicode Property, and you can match it using the `rebus` value `UP_DIACRITIC`.

Vietnamese makes heavy use of diacritics to denote the tones in its words. In this exercise, you'll manipulate the diacritics in the names of Vietnamese rulers.

#### Instructions
Names of rulers from the 18th Century Vietnamese Tây Sơn dynasty are shown in the script.

* `tay_son_builtin` has the accents built into each letter. Run the code that defines and prints this variable.
* Call `stri_trans_nfd()` to decompose the letters with accents into separate letter and accent characters, and assign the result to `tay_son_separate`.
* Print `tay_son_separate` to verify the names still display the same way.
* View all the accents by calling `str_view_all()` and matching `UP_DIACRITIC`. The match is shown after the letter that the diacritic belongs to.

```{r eval = F}
# Names with builtin accents
(tay_son_builtin <- c(
  "Nguy\u1ec5n Nh\u1ea1c", 
  "Nguy\u1ec5n Hu\u1ec7",
  "Nguy\u1ec5n Quang To\u1ea3n"
))

# Convert to separate accents
tay_son_separate <- stri_trans_nfd(tay_son_builtin)

# Verify that the string prints the same
tay_son_separate

# Match all accents
str_view_all(tay_son_separate, UP_DIACRITIC)
```

## Matching a single grapheme

A related problem is matching a single character. You've used ANY_CHAR to do this up until now, but it will only match a character represented by a single code point. Take these three names:

> x <- c("Adele", "Ad\u00e8le", "Ad\u0065\u0300le")  
> writeLines(x)

They look the similar, but this regular expression only matches two of them:

> str_view(x, "Ad" %R% ANY_CHAR %R% "le")

because in the third name è is represented by two code points. The Unicode standard has a concept of a grapheme that represents a display character, but may be composed of many code points. To match any grapheme you can use GRAPHEME.

> str_view(x, "Ad" %R% GRAPHEME %R% "le")

Names of rulers from the Vietnamese Tây Sơn dynasty, with diacritics given as separate graphemes, is pre-defined as `tay_son_separate`.

#### Instructions
* Use `str_view_all(),` with `ANY_CHAR` as a pattern to view each character in `tay_son_separate`.
* Do the same again with GRAPHEME as a pattern, to see the difference between characters and graphemes.
* Use `stri_trans_nfc()` to combine the diacritics with their associated characters, storing the result as `tay_son_builtin`.
* Use `str_view_all()` to view each grapheme in `tay_son_builtin`.

```{r eval = F}
str_view_all(tay_son_separate, ANY_CHAR)
str_view_all(tay_son_separate, GRAPHEME)

tay_son_builtin <- stri_trans_nfc(tay_son_separate)
tay_son_builtin

str_view_all(tay_son_builtin, GRAPHEME)
```

# 5th Segment - Case Studies

